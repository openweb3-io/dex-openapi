/* tslint:disable */
/* eslint-disable */
/**
 * Dex Aggregator API
 * Dex Aggregator API ⚡️
 *
 * The version of the OpenAPI document: 1.0
 * Contact: ai@sx.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CancelAllOrdersInput
 */
export interface CancelAllOrdersInput {
    /**
     * chain of the order
     * @type {string}
     * @memberof CancelAllOrdersInput
     */
    'chain': string;
    /**
     * dex of the order
     * @type {string}
     * @memberof CancelAllOrdersInput
     */
    'dex': string;
    /**
     * market address
     * @type {string}
     * @memberof CancelAllOrdersInput
     */
    'marketAddress': string;
    /**
     * user address
     * @type {string}
     * @memberof CancelAllOrdersInput
     */
    'userAddress': string;
    /**
     * side of the order
     * @type {string}
     * @memberof CancelAllOrdersInput
     */
    'side': string;
    /**
     * priority fee microLamports
     * @type {number}
     * @memberof CancelAllOrdersInput
     */
    'priorityFee'?: number;
    /**
     * limit of the order
     * @type {number}
     * @memberof CancelAllOrdersInput
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface CancelOrderInput
 */
export interface CancelOrderInput {
    /**
     * dex of the order
     * @type {string}
     * @memberof CancelOrderInput
     */
    'dex': string;
    /**
     * chain of the order
     * @type {string}
     * @memberof CancelOrderInput
     */
    'chain': string;
    /**
     * user address
     * @type {string}
     * @memberof CancelOrderInput
     */
    'userAddress': string;
    /**
     * market address
     * @type {string}
     * @memberof CancelOrderInput
     */
    'marketAddress': string;
    /**
     * order ids
     * @type {Array<string>}
     * @memberof CancelOrderInput
     */
    'orderIds': Array<string>;
    /**
     * client order ids
     * @type {Array<string>}
     * @memberof CancelOrderInput
     */
    'clientOrderIds': Array<string>;
    /**
     * priority fee microLamports
     * @type {number}
     * @memberof CancelOrderInput
     */
    'priorityFee'?: number;
    /**
     * extra
     * @type {object}
     * @memberof CancelOrderInput
     */
    'extra': object;
}
/**
 * 
 * @export
 * @interface CloseMarketInput
 */
export interface CloseMarketInput {
    /**
     * chain of the order
     * @type {string}
     * @memberof CloseMarketInput
     */
    'chain': string;
    /**
     * dex of the order
     * @type {string}
     * @memberof CloseMarketInput
     */
    'dex': string;
    /**
     * market address
     * @type {string}
     * @memberof CloseMarketInput
     */
    'marketAddress': string;
    /**
     * user address
     * @type {string}
     * @memberof CloseMarketInput
     */
    'userAddress': string;
    /**
     * priority fee microLamports
     * @type {number}
     * @memberof CloseMarketInput
     */
    'priorityFee'?: number;
    /**
     * extra
     * @type {object}
     * @memberof CloseMarketInput
     */
    'extra'?: object;
}
/**
 * 
 * @export
 * @interface CreateMarketInput
 */
export interface CreateMarketInput {
    /**
     * chain of the order
     * @type {string}
     * @memberof CreateMarketInput
     */
    'chain': string;
    /**
     * dex of the order
     * @type {string}
     * @memberof CreateMarketInput
     */
    'dex': string;
    /**
     * market name
     * @type {string}
     * @memberof CreateMarketInput
     */
    'name': string;
    /**
     * base mint address
     * @type {string}
     * @memberof CreateMarketInput
     */
    'baseMint': string;
    /**
     * quote mint address
     * @type {string}
     * @memberof CreateMarketInput
     */
    'quoteMint': string;
    /**
     * base lot size
     * @type {number}
     * @memberof CreateMarketInput
     */
    'baseLotSize': number;
    /**
     * quote lot size
     * @type {number}
     * @memberof CreateMarketInput
     */
    'quoteLotSize': number;
    /**
     * user address
     * @type {string}
     * @memberof CreateMarketInput
     */
    'userAddress': string;
    /**
     * priority fee microLamports
     * @type {number}
     * @memberof CreateMarketInput
     */
    'priorityFee'?: number;
    /**
     * maker fee
     * @type {number}
     * @memberof CreateMarketInput
     */
    'makerFee'?: number;
    /**
     * taker fee
     * @type {number}
     * @memberof CreateMarketInput
     */
    'takerFee'?: number;
    /**
     * time expiry
     * @type {number}
     * @memberof CreateMarketInput
     */
    'timeExpiry'?: number;
    /**
     * oracle a
     * @type {string}
     * @memberof CreateMarketInput
     */
    'oracleA'?: string;
    /**
     * oracle b
     * @type {string}
     * @memberof CreateMarketInput
     */
    'oracleB'?: string;
    /**
     * extra
     * @type {object}
     * @memberof CreateMarketInput
     */
    'extra'?: object;
}
/**
 * 
 * @export
 * @interface MintInput
 */
export interface MintInput {
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'migrationDex': string;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MintInput
     */
    'links': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'banner': string;
    /**
     * 
     * @type {string}
     * @memberof MintInput
     */
    'tokenAmount': string;
}
/**
 * 
 * @export
 * @interface PlaceOrderInput
 */
export interface PlaceOrderInput {
    /**
     * chain of the order
     * @type {string}
     * @memberof PlaceOrderInput
     */
    'chain': string;
    /**
     * dex of the order
     * @type {string}
     * @memberof PlaceOrderInput
     */
    'dex': string;
    /**
     * The order amount
     * @type {number}
     * @memberof PlaceOrderInput
     */
    'amount': number;
    /**
     * price of the order
     * @type {number}
     * @memberof PlaceOrderInput
     */
    'price': number;
    /**
     * side of the order
     * @type {string}
     * @memberof PlaceOrderInput
     */
    'side': PlaceOrderInputSideEnum;
    /**
     * market address
     * @type {string}
     * @memberof PlaceOrderInput
     */
    'marketAddress': string;
    /**
     * user address
     * @type {string}
     * @memberof PlaceOrderInput
     */
    'userAddress': string;
    /**
     * priority fee microLamports
     * @type {number}
     * @memberof PlaceOrderInput
     */
    'priorityFee'?: number;
}

export const PlaceOrderInputSideEnum = {
    Bid: 'bid',
    Ask: 'ask'
} as const;

export type PlaceOrderInputSideEnum = typeof PlaceOrderInputSideEnum[keyof typeof PlaceOrderInputSideEnum];

/**
 * 
 * @export
 * @interface PumpMintInput
 */
export interface PumpMintInput {
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'twitter': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'telegram': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'website': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'creator': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'migrationDex': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'icon': string;
    /**
     * 
     * @type {string}
     * @memberof PumpMintInput
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SendTxInput
 */
export interface SendTxInput {
    /**
     * Signed Transaction(base64)
     * @type {string}
     * @memberof SendTxInput
     */
    'signedTx': string;
    /**
     * SubmitType
     * @type {string}
     * @memberof SendTxInput
     */
    'submitType': string;
}
/**
 * 
 * @export
 * @interface SubmitInput
 */
export interface SubmitInput {
    /**
     * 
     * @type {string}
     * @memberof SubmitInput
     */
    'signedTx': string;
    /**
     * 
     * @type {object}
     * @memberof SubmitInput
     */
    'extra': object;
}
/**
 * 
 * @export
 * @interface SwapInput
 */
export interface SwapInput {
    /**
     * chain of the trade
     * @type {string}
     * @memberof SwapInput
     */
    'chain': string;
    /**
     * dex of the trade
     * @type {string}
     * @memberof SwapInput
     */
    'dex': string;
    /**
     * The address user choosed
     * @type {string}
     * @memberof SwapInput
     */
    'userAddress': string;
    /**
     * pool address
     * @type {string}
     * @memberof SwapInput
     */
    'poolAddress'?: string;
    /**
     * The amount
     * @type {string}
     * @memberof SwapInput
     */
    'amount': string;
    /**
     * The Swap Mode
     * @type {string}
     * @memberof SwapInput
     */
    'swapMode': string;
    /**
     * slippage tolerance (e.g., 10 for 10%)
     * @type {number}
     * @memberof SwapInput
     */
    'slippageBps': number | null;
    /**
     * Input Mint
     * @type {string}
     * @memberof SwapInput
     */
    'inputMint'?: string;
    /**
     * Ouput Mint
     * @type {string}
     * @memberof SwapInput
     */
    'outputMint'?: string;
    /**
     * priority fee
     * @type {string}
     * @memberof SwapInput
     */
    'priorityFee'?: string;
}

/**
 * DexApi - axios parameter creator
 * @export
 */
export const DexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SwapInput} swapInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dexControllerRoute: async (swapInput: SwapInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'swapInput' is not null or undefined
            assertParamExists('dexControllerRoute', 'swapInput', swapInput)
            const localVarPath = `/dex/route`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swapInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwapInput} swapInput params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dexControllerSwap: async (swapInput: SwapInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'swapInput' is not null or undefined
            assertParamExists('dexControllerSwap', 'swapInput', swapInput)
            const localVarPath = `/dex/swap`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swapInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DexApi - functional programming interface
 * @export
 */
export const DexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DexApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SwapInput} swapInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dexControllerRoute(swapInput: SwapInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dexControllerRoute(swapInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DexApi.dexControllerRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SwapInput} swapInput params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dexControllerSwap(swapInput: SwapInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dexControllerSwap(swapInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DexApi.dexControllerSwap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DexApi - factory interface
 * @export
 */
export const DexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DexApiFp(configuration)
    return {
        /**
         * 
         * @param {SwapInput} swapInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dexControllerRoute(swapInput: SwapInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dexControllerRoute(swapInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SwapInput} swapInput params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dexControllerSwap(swapInput: SwapInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.dexControllerSwap(swapInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DexApi - object-oriented interface
 * @export
 * @class DexApi
 * @extends {BaseAPI}
 */
export class DexApi extends BaseAPI {
    /**
     * 
     * @param {SwapInput} swapInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DexApi
     */
    public dexControllerRoute(swapInput: SwapInput, options?: RawAxiosRequestConfig) {
        return DexApiFp(this.configuration).dexControllerRoute(swapInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SwapInput} swapInput params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DexApi
     */
    public dexControllerSwap(swapInput: SwapInput, options?: RawAxiosRequestConfig) {
        return DexApiFp(this.configuration).dexControllerSwap(swapInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobApi - axios parameter creator
 * @export
 */
export const JobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobControllerGetJob: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobControllerGetJob', 'id', id)
            const localVarPath = `/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobControllerStreaming: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('jobControllerStreaming', 'id', id)
            const localVarPath = `/jobs/{id}/streaming`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobApi - functional programming interface
 * @export
 */
export const JobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobControllerGetJob(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobControllerGetJob(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.jobControllerGetJob']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobControllerStreaming(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobControllerStreaming(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobApi.jobControllerStreaming']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobApi - factory interface
 * @export
 */
export const JobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobControllerGetJob(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jobControllerGetJob(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobControllerStreaming(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jobControllerStreaming(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobApi - object-oriented interface
 * @export
 * @class JobApi
 * @extends {BaseAPI}
 */
export class JobApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public jobControllerGetJob(id: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).jobControllerGetJob(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobApi
     */
    public jobControllerStreaming(id: string, options?: RawAxiosRequestConfig) {
        return JobApiFp(this.configuration).jobControllerStreaming(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MoonshotApi - axios parameter creator
 * @export
 */
export const MoonshotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MintInput} mintInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonshotControllerMint: async (mintInput: MintInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mintInput' is not null or undefined
            assertParamExists('moonshotControllerMint', 'mintInput', mintInput)
            const localVarPath = `/solana/moonshot/mint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mintInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubmitInput} submitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonshotControllerSubmitMint: async (submitInput: SubmitInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitInput' is not null or undefined
            assertParamExists('moonshotControllerSubmitMint', 'submitInput', submitInput)
            const localVarPath = `/solana/moonshot/submitMint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoonshotApi - functional programming interface
 * @export
 */
export const MoonshotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MoonshotApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MintInput} mintInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonshotControllerMint(mintInput: MintInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonshotControllerMint(mintInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoonshotApi.moonshotControllerMint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubmitInput} submitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moonshotControllerSubmitMint(submitInput: SubmitInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moonshotControllerSubmitMint(submitInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoonshotApi.moonshotControllerSubmitMint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MoonshotApi - factory interface
 * @export
 */
export const MoonshotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MoonshotApiFp(configuration)
    return {
        /**
         * 
         * @param {MintInput} mintInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonshotControllerMint(mintInput: MintInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moonshotControllerMint(mintInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubmitInput} submitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moonshotControllerSubmitMint(submitInput: SubmitInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moonshotControllerSubmitMint(submitInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoonshotApi - object-oriented interface
 * @export
 * @class MoonshotApi
 * @extends {BaseAPI}
 */
export class MoonshotApi extends BaseAPI {
    /**
     * 
     * @param {MintInput} mintInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonshotApi
     */
    public moonshotControllerMint(mintInput: MintInput, options?: RawAxiosRequestConfig) {
        return MoonshotApiFp(this.configuration).moonshotControllerMint(mintInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubmitInput} submitInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoonshotApi
     */
    public moonshotControllerSubmitMint(submitInput: SubmitInput, options?: RawAxiosRequestConfig) {
        return MoonshotApiFp(this.configuration).moonshotControllerSubmitMint(submitInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OpenbookApi - axios parameter creator
 * @export
 */
export const OpenbookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} marketAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetMarketInfo: async (marketAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketAddress' is not null or undefined
            assertParamExists('openbookControllerGetMarketInfo', 'marketAddress', marketAddress)
            const localVarPath = `/solana/openbook/info/market/{marketAddress}`
                .replace(`{${"marketAddress"}}`, encodeURIComponent(String(marketAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetMarkets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/solana/openbook/info/all/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetOrderBook: async (marketAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketAddress' is not null or undefined
            assertParamExists('openbookControllerGetOrderBook', 'marketAddress', marketAddress)
            const localVarPath = `/solana/openbook/info/market/{marketAddress}/orderbook`
                .replace(`{${"marketAddress"}}`, encodeURIComponent(String(marketAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketAddress 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetUserOrders: async (marketAddress: string, userAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketAddress' is not null or undefined
            assertParamExists('openbookControllerGetUserOrders', 'marketAddress', marketAddress)
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('openbookControllerGetUserOrders', 'userAddress', userAddress)
            const localVarPath = `/solana/openbook/info/market/{marketAddress}/orderbook/userOrders/{userAddress}`
                .replace(`{${"marketAddress"}}`, encodeURIComponent(String(marketAddress)))
                .replace(`{${"userAddress"}}`, encodeURIComponent(String(userAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenbookApi - functional programming interface
 * @export
 */
export const OpenbookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenbookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} marketAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openbookControllerGetMarketInfo(marketAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openbookControllerGetMarketInfo(marketAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenbookApi.openbookControllerGetMarketInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openbookControllerGetMarkets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openbookControllerGetMarkets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenbookApi.openbookControllerGetMarkets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} marketAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openbookControllerGetOrderBook(marketAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openbookControllerGetOrderBook(marketAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenbookApi.openbookControllerGetOrderBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} marketAddress 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openbookControllerGetUserOrders(marketAddress: string, userAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openbookControllerGetUserOrders(marketAddress, userAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenbookApi.openbookControllerGetUserOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OpenbookApi - factory interface
 * @export
 */
export const OpenbookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenbookApiFp(configuration)
    return {
        /**
         * 
         * @param {string} marketAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetMarketInfo(marketAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.openbookControllerGetMarketInfo(marketAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetMarkets(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.openbookControllerGetMarkets(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetOrderBook(marketAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.openbookControllerGetOrderBook(marketAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketAddress 
         * @param {string} userAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openbookControllerGetUserOrders(marketAddress: string, userAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.openbookControllerGetUserOrders(marketAddress, userAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenbookApi - object-oriented interface
 * @export
 * @class OpenbookApi
 * @extends {BaseAPI}
 */
export class OpenbookApi extends BaseAPI {
    /**
     * 
     * @param {string} marketAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenbookApi
     */
    public openbookControllerGetMarketInfo(marketAddress: string, options?: RawAxiosRequestConfig) {
        return OpenbookApiFp(this.configuration).openbookControllerGetMarketInfo(marketAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenbookApi
     */
    public openbookControllerGetMarkets(options?: RawAxiosRequestConfig) {
        return OpenbookApiFp(this.configuration).openbookControllerGetMarkets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenbookApi
     */
    public openbookControllerGetOrderBook(marketAddress: string, options?: RawAxiosRequestConfig) {
        return OpenbookApiFp(this.configuration).openbookControllerGetOrderBook(marketAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketAddress 
     * @param {string} userAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenbookApi
     */
    public openbookControllerGetUserOrders(marketAddress: string, userAddress: string, options?: RawAxiosRequestConfig) {
        return OpenbookApiFp(this.configuration).openbookControllerGetUserOrders(marketAddress, userAddress, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CancelAllOrdersInput} cancelAllOrdersInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCancelAllOrders: async (cancelAllOrdersInput: CancelAllOrdersInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelAllOrdersInput' is not null or undefined
            assertParamExists('orderControllerCancelAllOrders', 'cancelAllOrdersInput', cancelAllOrdersInput)
            const localVarPath = `/orders/cancelAllOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelAllOrdersInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CancelOrderInput} cancelOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCancelOrder: async (cancelOrderInput: CancelOrderInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelOrderInput' is not null or undefined
            assertParamExists('orderControllerCancelOrder', 'cancelOrderInput', cancelOrderInput)
            const localVarPath = `/orders/cancelOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloseMarketInput} closeMarketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCloseMarket: async (closeMarketInput: CloseMarketInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'closeMarketInput' is not null or undefined
            assertParamExists('orderControllerCloseMarket', 'closeMarketInput', closeMarketInput)
            const localVarPath = `/orders/closeMarket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(closeMarketInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMarketInput} createMarketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCreateMarket: async (createMarketInput: CreateMarketInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMarketInput' is not null or undefined
            assertParamExists('orderControllerCreateMarket', 'createMarketInput', createMarketInput)
            const localVarPath = `/orders/createMarket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMarketInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PlaceOrderInput} placeOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerPlaceOrder: async (placeOrderInput: PlaceOrderInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeOrderInput' is not null or undefined
            assertParamExists('orderControllerPlaceOrder', 'placeOrderInput', placeOrderInput)
            const localVarPath = `/orders/placeOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeOrderInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PlaceOrderInput} placeOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerTakeOrder: async (placeOrderInput: PlaceOrderInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'placeOrderInput' is not null or undefined
            assertParamExists('orderControllerTakeOrder', 'placeOrderInput', placeOrderInput)
            const localVarPath = `/orders/takeOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(placeOrderInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CancelAllOrdersInput} cancelAllOrdersInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerCancelAllOrders(cancelAllOrdersInput: CancelAllOrdersInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerCancelAllOrders(cancelAllOrdersInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderControllerCancelAllOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CancelOrderInput} cancelOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerCancelOrder(cancelOrderInput: CancelOrderInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerCancelOrder(cancelOrderInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderControllerCancelOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloseMarketInput} closeMarketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerCloseMarket(closeMarketInput: CloseMarketInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerCloseMarket(closeMarketInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderControllerCloseMarket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CreateMarketInput} createMarketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerCreateMarket(createMarketInput: CreateMarketInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerCreateMarket(createMarketInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderControllerCreateMarket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PlaceOrderInput} placeOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerPlaceOrder(placeOrderInput: PlaceOrderInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerPlaceOrder(placeOrderInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderControllerPlaceOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PlaceOrderInput} placeOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerTakeOrder(placeOrderInput: PlaceOrderInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerTakeOrder(placeOrderInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderApi.orderControllerTakeOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @param {CancelAllOrdersInput} cancelAllOrdersInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCancelAllOrders(cancelAllOrdersInput: CancelAllOrdersInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderControllerCancelAllOrders(cancelAllOrdersInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CancelOrderInput} cancelOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCancelOrder(cancelOrderInput: CancelOrderInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderControllerCancelOrder(cancelOrderInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloseMarketInput} closeMarketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCloseMarket(closeMarketInput: CloseMarketInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderControllerCloseMarket(closeMarketInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMarketInput} createMarketInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCreateMarket(createMarketInput: CreateMarketInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderControllerCreateMarket(createMarketInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PlaceOrderInput} placeOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerPlaceOrder(placeOrderInput: PlaceOrderInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderControllerPlaceOrder(placeOrderInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PlaceOrderInput} placeOrderInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerTakeOrder(placeOrderInput: PlaceOrderInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.orderControllerTakeOrder(placeOrderInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @param {CancelAllOrdersInput} cancelAllOrdersInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderControllerCancelAllOrders(cancelAllOrdersInput: CancelAllOrdersInput, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderControllerCancelAllOrders(cancelAllOrdersInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CancelOrderInput} cancelOrderInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderControllerCancelOrder(cancelOrderInput: CancelOrderInput, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderControllerCancelOrder(cancelOrderInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloseMarketInput} closeMarketInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderControllerCloseMarket(closeMarketInput: CloseMarketInput, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderControllerCloseMarket(closeMarketInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMarketInput} createMarketInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderControllerCreateMarket(createMarketInput: CreateMarketInput, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderControllerCreateMarket(createMarketInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaceOrderInput} placeOrderInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderControllerPlaceOrder(placeOrderInput: PlaceOrderInput, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderControllerPlaceOrder(placeOrderInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaceOrderInput} placeOrderInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderControllerTakeOrder(placeOrderInput: PlaceOrderInput, options?: RawAxiosRequestConfig) {
        return OrderApiFp(this.configuration).orderControllerTakeOrder(placeOrderInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PumpfunApi - axios parameter creator
 * @export
 */
export const PumpfunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PumpMintInput} pumpMintInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pumpfunControllerMint: async (pumpMintInput: PumpMintInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pumpMintInput' is not null or undefined
            assertParamExists('pumpfunControllerMint', 'pumpMintInput', pumpMintInput)
            const localVarPath = `/solana/pumpfun/mint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pumpMintInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubmitInput} submitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pumpfunControllerSubmitMint: async (submitInput: SubmitInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitInput' is not null or undefined
            assertParamExists('pumpfunControllerSubmitMint', 'submitInput', submitInput)
            const localVarPath = `/solana/pumpfun/submitMint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PumpfunApi - functional programming interface
 * @export
 */
export const PumpfunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PumpfunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PumpMintInput} pumpMintInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pumpfunControllerMint(pumpMintInput: PumpMintInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pumpfunControllerMint(pumpMintInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PumpfunApi.pumpfunControllerMint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubmitInput} submitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pumpfunControllerSubmitMint(submitInput: SubmitInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pumpfunControllerSubmitMint(submitInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PumpfunApi.pumpfunControllerSubmitMint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PumpfunApi - factory interface
 * @export
 */
export const PumpfunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PumpfunApiFp(configuration)
    return {
        /**
         * 
         * @param {PumpMintInput} pumpMintInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pumpfunControllerMint(pumpMintInput: PumpMintInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pumpfunControllerMint(pumpMintInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubmitInput} submitInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pumpfunControllerSubmitMint(submitInput: SubmitInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pumpfunControllerSubmitMint(submitInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PumpfunApi - object-oriented interface
 * @export
 * @class PumpfunApi
 * @extends {BaseAPI}
 */
export class PumpfunApi extends BaseAPI {
    /**
     * 
     * @param {PumpMintInput} pumpMintInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PumpfunApi
     */
    public pumpfunControllerMint(pumpMintInput: PumpMintInput, options?: RawAxiosRequestConfig) {
        return PumpfunApiFp(this.configuration).pumpfunControllerMint(pumpMintInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubmitInput} submitInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PumpfunApi
     */
    public pumpfunControllerSubmitMint(submitInput: SubmitInput, options?: RawAxiosRequestConfig) {
        return PumpfunApiFp(this.configuration).pumpfunControllerSubmitMint(submitInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 * @export
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} chain 
         * @param {SendTxInput} sendTxInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionControllerSend: async (chain: string, sendTxInput: SendTxInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chain' is not null or undefined
            assertParamExists('transactionControllerSend', 'chain', chain)
            // verify required parameter 'sendTxInput' is not null or undefined
            assertParamExists('transactionControllerSend', 'sendTxInput', sendTxInput)
            const localVarPath = `/transaction/{chain}/send`
                .replace(`{${"chain"}}`, encodeURIComponent(String(chain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTxInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 * @export
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} chain 
         * @param {SendTxInput} sendTxInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionControllerSend(chain: string, sendTxInput: SendTxInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionControllerSend(chain, sendTxInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.transactionControllerSend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 * @export
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @param {string} chain 
         * @param {SendTxInput} sendTxInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionControllerSend(chain: string, sendTxInput: SendTxInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.transactionControllerSend(chain, sendTxInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 * @export
 * @class TransactionApi
 * @extends {BaseAPI}
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @param {string} chain 
     * @param {SendTxInput} sendTxInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionApi
     */
    public transactionControllerSend(chain: string, sendTxInput: SendTxInput, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).transactionControllerSend(chain, sendTxInput, options).then((request) => request(this.axios, this.basePath));
    }
}



